;;;; procura.lisp
;;;; Alogritmos de porcura
;;;; Autores: Rodrigo Santos e João Fernandes

(defun bfs (tabuleiro)
  (let ((abertos (list (list nil nil tabuleiro)))  ; Inicializa a lista de abertos
        (fechados '()))                           ; Inicializa a lista de fechados
    (loop
       (if (null abertos)  ; Se a lista de abertos estiver vazia, termine a busca
           (return nil))   ; Não encontrou o objetivo
      (let ((node (first abertos)))  ; Pega o primeiro nó da lista de abertos
        (setq abertos (rest abertos))  ; Remove o nó atual da lista de abertos
        (push node fechados)  ; Adiciona o nó atual à lista de fechados
        (if (tabuleiro-vaziop (third node))  ; Verifica se é o objetivo
            (return (caminho node fechados)))  ; Retorna o caminho completo até o objetivo
        (let ((sucessores (gerar-filhos (third node))))  ; Gera sucessores
          (dolist (s sucessores)  ; Itera sobre cada sucessor
            (unless (or (member (third s) (mapcar #'third abertos) :test #'equal)  ; Verifica se está em abertos
                        (member (third s) (mapcar #'third fechados) :test #'equal))  ; Verifica se está em fechados
              (setq abertos (append abertos (list s))))))))))



(defun caminho (node fechados &optional (solucao '()))
  (let* ((tabuleiro-pai (first node))  ; Pega o tabuleiro-pai do nó completo
         (operacao (second node)))     ; Pega a operação do nó completo
    (if (null tabuleiro-pai)  ; Se o tabuleiro pai é nil, retornamos o caminho
        solucao   ; O caminho deve ser invertido, pois estamos acumulando as operações em ordem reversa
        (progn
          (dolist (n fechados)  ; Itera sobre os nós em fechados
  (when (equal (third n) (first node))  ; Verifica se o tabuleiro-pai do nó em fechados é igual ao node
    (return (caminho n  ; Chama recursivamente com o nó pai
                      fechados
                      (cons operacao solucao)))))  ; Adiciona a operação ao caminho
))))  ; Adiciona a operação ao caminho







(defun gerar-filhos (node &optional (linha 0) (coluna 0) (resultados '()))
  "Gera sucessores de forma recursiva a partir de uma matriz, ignorando células não distribuíveis."
  (let ((matriz (third node)))
    (if (>= linha (length matriz)) ; Se percorremos todas as linhas, terminar.
        resultados
      (let ((nova-linha (if (>= coluna (length (nth linha matriz)))
                            (1+ linha)
                          linha))
            (nova-coluna (if (>= coluna (length (nth linha matriz)))
                             0
                           (1+ coluna))))
        (if (and (< linha (length matriz)) ; Validar que ainda estamos na matriz.
                 (< coluna (length (nth linha matriz)))
                 (celula-distribuivelp linha coluna matriz))
            (let* ((tabuleiro-pai node)
                   (operacao (list linha coluna))
                   (filho (operador linha coluna matriz))
                   (resultado (list tabuleiro-pai operacao filho)))
              (gerar-filhos node nova-linha nova-coluna (cons resultado resultados)))
          (gerar-filhos node nova-linha nova-coluna resultados)))))) ; Avançar para a próxima célula.




(defun celula-distribuivelp (linha coluna matriz)
  "Retorna T se a célula tem peças suficientes para uma distribuição válida."
  (let ((valor (celula linha coluna matriz)))
    (and (> valor 0) t)))


